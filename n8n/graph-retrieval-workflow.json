{
  "name": "Graph Retrieval Adapter",
  "active": false,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "graph-retrieve",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "retrieve-webhook",
      "name": "Retrieve Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "graph-retrieve-webhook"
    },
    {
      "parameters": {
        "jsCode": "const body = $input.first().json.body || {};\n\nconst query = body.query || '';\nconst entity = body.entity || '';\nconst queryType = body.query_type || 'entity_context';\nconst maxDepth = Math.min(body.max_depth || 2, 4);\nconst limit = Math.min(body.limit || 20, 50);\n\nif (!query && !entity) {\n  return [{ json: { error: true, message: 'Either query or entity is required' } }];\n}\n\nreturn [{\n  json: {\n    query: query.trim(),\n    entity: entity.trim(),\n    query_type: queryType,\n    max_depth: maxDepth,\n    limit: limit,\n    error: false\n  }\n}];"
      },
      "id": "validate-input",
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
          "conditions": [
            {
              "id": "check-error",
              "leftValue": "={{ $json.error }}",
              "rightValue": false,
              "operator": { "type": "boolean", "operation": "equals" }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "check-valid",
      "name": "Check Valid",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\nconst queryType = input.query_type;\nconst entity = input.entity;\nconst query = input.query;\nconst maxDepth = input.max_depth;\nconst limit = input.limit;\n\nlet cypher = '';\nlet params = {};\n\nswitch (queryType) {\n  case 'entity_context':\n    // Get entity with all its relationships\n    cypher = `\n      MATCH (e:Entity)\n      WHERE e.name =~ $pattern OR e.id = $entity\n      OPTIONAL MATCH (e)-[r1]->(related:Entity)\n      OPTIONAL MATCH (e)<-[r2]-(incoming:Entity)\n      OPTIONAL MATCH (d:Document)-[:MENTIONS]->(e)\n      RETURN e.id as entity_id, e.name as entity_name, e.type as entity_type, e.description as entity_desc,\n             collect(DISTINCT {name: related.name, type: related.type, relation: type(r1)}) as outgoing,\n             collect(DISTINCT {name: incoming.name, type: incoming.type, relation: type(r2)}) as incoming,\n             collect(DISTINCT {id: d.id, title: d.title}) as documents\n      LIMIT $limit\n    `;\n    params = { \n      pattern: '(?i).*' + (entity || query).replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') + '.*',\n      entity: entity || query,\n      limit: limit \n    };\n    break;\n\n  case 'find_path':\n    // Find paths between two entities\n    const [source, target] = (query || '').split(',').map(s => s.trim());\n    cypher = `\n      MATCH (source:Entity), (target:Entity)\n      WHERE (source.name =~ $sourcePattern OR source.id = $source)\n        AND (target.name =~ $targetPattern OR target.id = $target)\n      MATCH path = shortestPath((source)-[*1..${maxDepth}]-(target))\n      RETURN [n IN nodes(path) | {name: n.name, type: n.type}] as path_nodes,\n             [r IN relationships(path) | type(r)] as path_relations\n      LIMIT $limit\n    `;\n    params = {\n      source: source || '',\n      target: target || '',\n      sourcePattern: '(?i).*' + (source || '').replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') + '.*',\n      targetPattern: '(?i).*' + (target || '').replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') + '.*',\n      limit: limit\n    };\n    break;\n\n  case 'related_entities':\n    // Get entities related within N hops\n    cypher = `\n      MATCH (e:Entity)\n      WHERE e.name =~ $pattern OR e.id = $entity\n      MATCH path = (e)-[*1..${maxDepth}]-(related:Entity)\n      WHERE related <> e\n      RETURN DISTINCT related.name as name, related.type as type, related.description as description,\n             length(path) as distance\n      ORDER BY distance, related.type\n      LIMIT $limit\n    `;\n    params = {\n      pattern: '(?i).*' + (entity || query).replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') + '.*',\n      entity: entity || query,\n      limit: limit\n    };\n    break;\n\n  case 'team_services':\n    // Get services owned by a team\n    cypher = `\n      MATCH (t:Entity {type: 'Team'})\n      WHERE t.name =~ $pattern OR t.id = $team\n      OPTIONAL MATCH (t)-[:OWNS]->(s:Entity {type: 'Service'})\n      OPTIONAL MATCH (s)-[:DEPENDS_ON]->(dep:Entity)\n      RETURN t.name as team, \n             collect(DISTINCT {name: s.name, description: s.description}) as services,\n             collect(DISTINCT {service: s.name, depends_on: dep.name}) as dependencies\n      LIMIT $limit\n    `;\n    params = {\n      pattern: '(?i).*' + (entity || query).replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') + '.*',\n      team: entity || query,\n      limit: limit\n    };\n    break;\n\n  case 'document_entities':\n    // Get all entities mentioned in a document\n    cypher = `\n      MATCH (d:Document)\n      WHERE d.id = $docId OR d.title =~ $pattern\n      OPTIONAL MATCH (d)-[:MENTIONS]->(e:Entity)\n      OPTIONAL MATCH (d)-[:ABOUT]->(c:Concept)\n      RETURN d.id as doc_id, d.title as doc_title,\n             collect(DISTINCT {name: e.name, type: e.type}) as entities,\n             collect(DISTINCT {name: c.name, category: c.category}) as concepts\n      LIMIT $limit\n    `;\n    params = {\n      docId: entity || query,\n      pattern: '(?i).*' + (entity || query).replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') + '.*',\n      limit: limit\n    };\n    break;\n\n  case 'concept_documents':\n    // Get documents about a concept\n    cypher = `\n      MATCH (c:Concept)\n      WHERE c.name =~ $pattern OR c.id = $concept\n      OPTIONAL MATCH (d:Document)-[r:ABOUT]->(c)\n      RETURN c.name as concept, c.category as category,\n             collect({doc_id: d.id, title: d.title, relevance: r.relevance}) as documents\n      ORDER BY r.relevance DESC\n      LIMIT $limit\n    `;\n    params = {\n      pattern: '(?i).*' + (entity || query).replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') + '.*',\n      concept: entity || query,\n      limit: limit\n    };\n    break;\n\n  default:\n    // Fuzzy search across all entities\n    cypher = `\n      MATCH (e:Entity)\n      WHERE e.name =~ $pattern\n      RETURN e.name as name, e.type as type, e.description as description\n      ORDER BY e.type, e.name\n      LIMIT $limit\n    `;\n    params = {\n      pattern: '(?i).*' + (query || entity).replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') + '.*',\n      limit: limit\n    };\n}\n\nreturn [{\n  json: {\n    cypher: cypher,\n    params: params,\n    query_type: queryType,\n    original_query: query,\n    original_entity: entity\n  }\n}];"
      },
      "id": "build-query",
      "name": "Build Cypher Query",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://neo4j:7474/db/neo4j/tx/commit",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"statements\": [\n    {\n      \"statement\": {{ JSON.stringify($json.cypher) }},\n      \"parameters\": {{ JSON.stringify($json.params) }}\n    }\n  ]\n}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "query-neo4j",
      "name": "Query Neo4j",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1120, 200],
      "credentials": {
        "httpBasicAuth": {
          "id": "neo4j-creds",
          "name": "Neo4j Credentials"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const neo4jResponse = $input.first().json;\nconst queryInfo = $('Build Cypher Query').first().json;\n\n// Check for errors\nif (neo4jResponse.errors && neo4jResponse.errors.length > 0) {\n  return [{\n    json: {\n      success: false,\n      error: neo4jResponse.errors[0].message,\n      context: null\n    }\n  }];\n}\n\nconst results = neo4jResponse.results?.[0]?.data || [];\nconst columns = neo4jResponse.results?.[0]?.columns || [];\n\n// Convert to array of objects\nconst rows = results.map(r => {\n  const obj = {};\n  columns.forEach((col, i) => {\n    obj[col] = r.row[i];\n  });\n  return obj;\n});\n\n// Build LLM-friendly context based on query type\nlet contextText = '';\nconst queryType = queryInfo.query_type;\n\nswitch (queryType) {\n  case 'entity_context':\n    rows.forEach(row => {\n      contextText += `## ${row.entity_name} (${row.entity_type})\\n`;\n      if (row.entity_desc) contextText += `${row.entity_desc}\\n`;\n      contextText += '\\n';\n      \n      const outgoing = (row.outgoing || []).filter(o => o.name);\n      if (outgoing.length > 0) {\n        contextText += 'Related to:\\n';\n        outgoing.forEach(o => {\n          contextText += `- ${o.relation} → ${o.name} (${o.type})\\n`;\n        });\n        contextText += '\\n';\n      }\n      \n      const incoming = (row.incoming || []).filter(i => i.name);\n      if (incoming.length > 0) {\n        contextText += 'Referenced by:\\n';\n        incoming.forEach(i => {\n          contextText += `- ${i.name} (${i.type}) ${i.relation} → this\\n`;\n        });\n        contextText += '\\n';\n      }\n      \n      const docs = (row.documents || []).filter(d => d.id);\n      if (docs.length > 0) {\n        contextText += 'Mentioned in documents:\\n';\n        docs.forEach(d => {\n          contextText += `- ${d.title || d.id}\\n`;\n        });\n      }\n    });\n    break;\n\n  case 'find_path':\n    rows.forEach((row, idx) => {\n      contextText += `Path ${idx + 1}:\\n`;\n      const nodes = row.path_nodes || [];\n      const rels = row.path_relations || [];\n      nodes.forEach((n, i) => {\n        contextText += `  ${n.name} (${n.type})`;\n        if (i < rels.length) {\n          contextText += ` --[${rels[i]}]--> `;\n        }\n      });\n      contextText += '\\n\\n';\n    });\n    break;\n\n  case 'related_entities':\n    contextText += 'Related entities:\\n';\n    rows.forEach(row => {\n      contextText += `- ${row.name} (${row.type})`;\n      if (row.distance) contextText += ` [${row.distance} hop(s)]`;\n      if (row.description) contextText += `: ${row.description}`;\n      contextText += '\\n';\n    });\n    break;\n\n  case 'team_services':\n    rows.forEach(row => {\n      contextText += `## Team: ${row.team}\\n\\n`;\n      const services = (row.services || []).filter(s => s.name);\n      if (services.length > 0) {\n        contextText += 'Owned services:\\n';\n        services.forEach(s => {\n          contextText += `- ${s.name}`;\n          if (s.description) contextText += `: ${s.description}`;\n          contextText += '\\n';\n        });\n        contextText += '\\n';\n      }\n      const deps = (row.dependencies || []).filter(d => d.service && d.depends_on);\n      if (deps.length > 0) {\n        contextText += 'Service dependencies:\\n';\n        deps.forEach(d => {\n          contextText += `- ${d.service} depends on ${d.depends_on}\\n`;\n        });\n      }\n    });\n    break;\n\n  case 'document_entities':\n    rows.forEach(row => {\n      contextText += `## Document: ${row.doc_title || row.doc_id}\\n\\n`;\n      const entities = (row.entities || []).filter(e => e.name);\n      if (entities.length > 0) {\n        contextText += 'Entities mentioned:\\n';\n        entities.forEach(e => {\n          contextText += `- ${e.name} (${e.type})\\n`;\n        });\n        contextText += '\\n';\n      }\n      const concepts = (row.concepts || []).filter(c => c.name);\n      if (concepts.length > 0) {\n        contextText += 'Concepts:\\n';\n        concepts.forEach(c => {\n          contextText += `- ${c.name} [${c.category}]\\n`;\n        });\n      }\n    });\n    break;\n\n  case 'concept_documents':\n    rows.forEach(row => {\n      contextText += `## Concept: ${row.concept} (${row.category})\\n\\n`;\n      const docs = (row.documents || []).filter(d => d.doc_id);\n      if (docs.length > 0) {\n        contextText += 'Related documents:\\n';\n        docs.forEach(d => {\n          contextText += `- ${d.title || d.doc_id}`;\n          if (d.relevance) contextText += ` (relevance: ${d.relevance})`;\n          contextText += '\\n';\n        });\n      }\n    });\n    break;\n\n  default:\n    contextText += 'Search results:\\n';\n    rows.forEach(row => {\n      contextText += `- ${row.name} (${row.type})`;\n      if (row.description) contextText += `: ${row.description}`;\n      contextText += '\\n';\n    });\n}\n\nreturn [{\n  json: {\n    success: true,\n    query_type: queryType,\n    result_count: rows.length,\n    results: rows,\n    context: contextText.trim() || 'No results found.',\n    document_ids: rows.flatMap(r => (r.documents || []).map(d => d.id)).filter(Boolean)\n  }\n}];"
      },
      "id": "format-context",
      "name": "Format LLM Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 200]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}"
      },
      "id": "success-response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1560, 200]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({success: false, error: $json.message}) }}",
        "options": { "responseCode": 400 }
      },
      "id": "error-response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [900, 400]
    }
  ],
  "connections": {
    "Retrieve Webhook": {
      "main": [[{"node": "Validate Input", "type": "main", "index": 0}]]
    },
    "Validate Input": {
      "main": [[{"node": "Check Valid", "type": "main", "index": 0}]]
    },
    "Check Valid": {
      "main": [
        [{"node": "Build Cypher Query", "type": "main", "index": 0}],
        [{"node": "Error Response", "type": "main", "index": 0}]
      ]
    },
    "Build Cypher Query": {
      "main": [[{"node": "Query Neo4j", "type": "main", "index": 0}]]
    },
    "Query Neo4j": {
      "main": [[{"node": "Format LLM Context", "type": "main", "index": 0}]]
    },
    "Format LLM Context": {
      "main": [[{"node": "Success Response", "type": "main", "index": 0}]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "meta": {
    "description": "Retrieval adapter that queries Neo4j graph database and returns structured context for LLM prompting. Supports multiple query types including entity context, path finding, and related entities."
  }
}
